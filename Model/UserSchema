const mongooose = require("mongoose");
const bcrypt = require("bcrypt");
const joi = require("joi");
const CustomError = require("../Errors");

const UserScheme = new mongooose.Schema(
  {
    fullname: {
      type: String,
      required: true,
    },
    username: {
      type: String,
      required: true,
    },
    email: {
      type: String,
      unique: true,
      required: true,
    },
    password: {
      type: String,
      required: true,
    },
    dob: {
      type: String,
      required: true,
    },
    img: {
      type: String,
    },
    role: {
      type: String,
      enum: ["user", "admin", "superAdmin"],
      default: "user",
    },
    accessToken: {
      type: String,
    },
    refreshToken: {
      type: String,
    },
  },
  { timestamps: true }
);

UserScheme.pre("save", async function (next) {
  const saltRounds = 10;
  const salt = await bcrypt.genSalt(saltRounds);
  this.password = await bcrypt.hash(this.password, salt);
});

UserScheme.statics.login = async function (email, password) {
  const user = await this.findOne({ email });

  if (user) {
    const auth = await bcrypt.compare(password, user.password);

    if (auth) {
      return user;
    }
    
    throw new CustomError.AuthenticationError(
      "invalid password, try again."
    );
  }

  throw new CustomError.AuthenticationError(
    "invalid email try again."
  );
};

UserScheme.recovery = async function (email) {
  const user = await this.findOne({ email });

  if (user) {
    console.log("exists");
  } else {
    console.log("invalid email");
  }
};

UserScheme.methods.compare = async (password) => {
  const comparePassword = await bcrypt.compare(password, this.password);
  return comparePassword;
};

module.exports = mongooose.model("Users", UserScheme);
